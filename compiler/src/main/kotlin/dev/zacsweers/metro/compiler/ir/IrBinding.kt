// Copyright (C) 2024 Zac Sweers
// SPDX-License-Identifier: Apache-2.0
package dev.zacsweers.metro.compiler.ir

import dev.drewhamilton.poko.Poko
import dev.zacsweers.metro.compiler.MetroAnnotations
import dev.zacsweers.metro.compiler.Symbols
import dev.zacsweers.metro.compiler.appendLineWithUnderlinedContent
import dev.zacsweers.metro.compiler.capitalizeUS
import dev.zacsweers.metro.compiler.expectAs
import dev.zacsweers.metro.compiler.expectAsOrNull
import dev.zacsweers.metro.compiler.graph.BaseBinding
import dev.zacsweers.metro.compiler.graph.LocationDiagnostic
import dev.zacsweers.metro.compiler.ir.parameters.Parameter
import dev.zacsweers.metro.compiler.ir.parameters.Parameters
import dev.zacsweers.metro.compiler.isWordPrefixRegex
import dev.zacsweers.metro.compiler.memoize
import dev.zacsweers.metro.compiler.reportCompilerBug
import java.util.TreeSet
import org.jetbrains.kotlin.ir.declarations.IrClass
import org.jetbrains.kotlin.ir.declarations.IrDeclarationContainer
import org.jetbrains.kotlin.ir.declarations.IrDeclarationParent
import org.jetbrains.kotlin.ir.declarations.IrDeclarationWithName
import org.jetbrains.kotlin.ir.declarations.IrField
import org.jetbrains.kotlin.ir.declarations.IrFunction
import org.jetbrains.kotlin.ir.declarations.IrPackageFragment
import org.jetbrains.kotlin.ir.declarations.IrProperty
import org.jetbrains.kotlin.ir.declarations.IrSimpleFunction
import org.jetbrains.kotlin.ir.declarations.IrValueParameter
import org.jetbrains.kotlin.ir.types.IrType
import org.jetbrains.kotlin.ir.types.isUnit
import org.jetbrains.kotlin.ir.types.typeOrFail
import org.jetbrains.kotlin.ir.util.callableId
import org.jetbrains.kotlin.ir.util.classId
import org.jetbrains.kotlin.ir.util.dumpKotlinLike
import org.jetbrains.kotlin.ir.util.hasAnnotation
import org.jetbrains.kotlin.ir.util.isPropertyAccessor
import org.jetbrains.kotlin.ir.util.kotlinFqName
import org.jetbrains.kotlin.ir.util.parentAsClass
import org.jetbrains.kotlin.ir.util.parentClassOrNull
import org.jetbrains.kotlin.ir.util.parentDeclarationsWithSelf
import org.jetbrains.kotlin.ir.util.propertyIfAccessor
import org.jetbrains.kotlin.name.CallableId
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.Name

internal sealed interface IrBinding : BaseBinding<IrType, IrTypeKey, IrContextualTypeKey> {
  override val typeKey: IrTypeKey
    get() = contextualTypeKey.typeKey

  val scope: IrAnnotation?
  // Track the list of parameters, which may not have unique type keys
  val parameters: Parameters
  val nameHint: String
  override val contextualTypeKey: IrContextualTypeKey
  val reportableDeclaration: IrDeclarationWithName?

  /**
   * Returns true if this binding should be scoped (cached) in the graph. For most bindings, this is
   * true if [scope] != null. For [GraphExtension] bindings, this is true if
   * [GraphExtension.extensionScopes] is not empty.
   */
  fun isScoped(): Boolean = scope != null

  override fun renderLocationDiagnostic(short: Boolean): LocationDiagnostic {
    // First check if we have the contributing file and line number
    val binding = this
    val locationString =
      reportableDeclaration?.locationOrNull()?.render(short)
        // Or the fully-qualified contributing class name
        // TODO is this right
        ?: parameters.allParameters.firstOrNull()?.typeKey?.render(short = short)
        // Or print the full set of info we know about the binding
        ?: buildString {
          appendLine("Unknown source location, this may be generated by the compiler.")
          appendLine("└─ Here's some additional information we have for the binding:")
          append("   ├─ Binding type: ")
          appendLine(binding.javaClass.simpleName)
          append("   └─ Binding information: ")
          appendLine(binding)
        }
    return LocationDiagnostic(
      locationString,
      renderDescriptionDiagnostic(short = short, underlineTypeKey = true),
    )
  }

  sealed interface BindingWithAnnotations : IrBinding {
    val annotations: MetroAnnotations<IrAnnotation>
  }

  sealed interface InjectedClassBinding<T : InjectedClassBinding<T>> :
    BindingWithAnnotations, IrBinding {
    val type: IrClass

    fun withMapKey(mapKey: IrAnnotation?): T
  }

  @Poko
  class ConstructorInjected(
    @Poko.Skip override val type: IrClass,
    @Poko.Skip val classFactory: ClassFactory,
    override val annotations: MetroAnnotations<IrAnnotation>,
    override val typeKey: IrTypeKey,
    val injectedMembers: Set<IrContextualTypeKey>,
  ) : IrBinding, BindingWithAnnotations, InjectedClassBinding<ConstructorInjected> {
    override val parameters: Parameters = classFactory.targetFunctionParameters

    val isAssisted
      get() = classFactory.isAssistedInject

    override val dependencies: List<IrContextualTypeKey> by memoize {
      parameters.nonDispatchParameters.filterNot { it.isAssisted }.map { it.contextualTypeKey } +
        injectedMembers
    }

    override val scope: IrAnnotation?
      get() = annotations.scope

    override val nameHint: String = type.name.asString()
    override val contextualTypeKey: IrContextualTypeKey = IrContextualTypeKey.create(typeKey)

    override val reportableDeclaration: IrDeclarationWithName
      get() = type

    fun parameterFor(typeKey: IrTypeKey) =
      classFactory.function.regularParameters.getOrNull(
        parameters.regularParameters.indexOfFirst { it.typeKey == typeKey }
      )

    override fun renderDescriptionDiagnostic(short: Boolean, underlineTypeKey: Boolean): String =
      buildString {
        type.renderForDiagnostic(
          short = short,
          annotations = annotations,
          underlineTypeKey = underlineTypeKey,
        )
      }

    override fun toString() = renderDescriptionDiagnostic(short = true, underlineTypeKey = false)

    override fun withMapKey(mapKey: IrAnnotation?): ConstructorInjected {
      if (mapKey == null) return this
      return ConstructorInjected(
        type = type,
        classFactory = classFactory,
        annotations = annotations.copy(mapKeys = annotations.mapKeys + mapKey),
        typeKey = typeKey,
        injectedMembers = injectedMembers,
      )
    }
  }

  class ObjectClass(
    @Poko.Skip override val type: IrClass,
    override val annotations: MetroAnnotations<IrAnnotation>,
    override val typeKey: IrTypeKey,
  ) : IrBinding, BindingWithAnnotations, InjectedClassBinding<ObjectClass> {
    override val dependencies: List<IrContextualTypeKey> = emptyList()
    override val scope: IrAnnotation? = null
    override val parameters: Parameters = Parameters.empty()
    override val isImplicitlyDeferrable: Boolean = true

    override val nameHint: String = type.name.asString()
    override val contextualTypeKey: IrContextualTypeKey = IrContextualTypeKey.create(typeKey)

    override val reportableDeclaration: IrDeclarationWithName
      get() = type

    override fun renderDescriptionDiagnostic(short: Boolean, underlineTypeKey: Boolean): String =
      buildString {
        type.renderForDiagnostic(
          short = short,
          annotations = annotations,
          underlineTypeKey = underlineTypeKey,
        )
      }

    override fun toString() = renderDescriptionDiagnostic(short = true, underlineTypeKey = false)

    override fun withMapKey(mapKey: IrAnnotation?): ObjectClass {
      if (mapKey == null) return this
      return ObjectClass(type, annotations.copy(mapKeys = annotations.mapKeys + mapKey), typeKey)
    }
  }

  /** A binding that is statically defined in a graph or binding container. */
  sealed interface StaticBinding : IrBinding, BindingWithAnnotations

  @Poko
  class Provided(
    @Poko.Skip val providerFactory: ProviderFactory,
    override val annotations: MetroAnnotations<IrAnnotation>,
    override val contextualTypeKey: IrContextualTypeKey,
    override val parameters: Parameters,
  ) : StaticBinding {
    override val dependencies: List<IrContextualTypeKey> by memoize {
      parameters.allParameters.map { it.contextualTypeKey }
    }

    override val scope: IrAnnotation?
      get() = annotations.scope

    val intoSet: Boolean
      get() = annotations.isIntoSet

    val elementsIntoSet: Boolean
      get() = annotations.isElementsIntoSet

    // TODO are both necessary? Is there any case where only one is specified?
    val intoMap: Boolean
      get() = annotations.isIntoMap

    val mapKey: IrAnnotation? = annotations.mapKeys.singleOrNull()
    override val typeKey: IrTypeKey = contextualTypeKey.typeKey

    val isIntoMultibinding
      get() = annotations.isIntoMultibinding

    override val nameHint: String = providerFactory.callableId.callableName.asString()

    override val reportableDeclaration: IrDeclarationWithName
      get() = providerFactory.function

    fun parameterFor(typeKey: IrTypeKey): IrValueParameter {
      return parameters.allParameters
        .find { it.typeKey == typeKey }
        ?.ir
        ?.expectAs<IrValueParameter>()
        ?: reportCompilerBug(
          "No value parameter found for key $typeKey in ${providerFactory.callableId.asSingleFqName().asString()}."
        )
    }

    override fun renderDescriptionDiagnostic(short: Boolean, underlineTypeKey: Boolean) =
      buildString {
        renderForDiagnostic(
          declaration = providerFactory.function,
          short = short,
          typeKey = providerFactory.typeKey,
          annotations = providerFactory.annotations,
          parameters = providerFactory.parameters,
          isProperty = providerFactory.isPropertyAccessor,
          underlineTypeKey = underlineTypeKey,
        )
      }

    override fun toString() = renderDescriptionDiagnostic(short = true, underlineTypeKey = false)
  }

  /** Represents an aliased binding, i.e. `@Binds`. Can be a multibinding. */
  @Poko
  class Alias(
    override val typeKey: IrTypeKey,
    val aliasedType: IrTypeKey,
    val bindsCallable: BindsCallable?,
    override val parameters: Parameters,
  ) : StaticBinding {
    val ir = bindsCallable?.function
    override val annotations: MetroAnnotations<IrAnnotation> =
      bindsCallable?.callableMetadata?.annotations ?: MetroAnnotations.none()
    override val isAlias: Boolean = true

    init {
      if (ir != null && !annotations.isBinds) {
        reportCompilerBug("Aliases must be binds!")
      }
    }

    fun aliasedBinding(graph: IrBindingGraph): IrBinding {
      // O(1) lookup at this point
      return graph.requireBinding(contextualTypeKey.withTypeKey(aliasedType))
    }

    override val scope: IrAnnotation? = null
    override val dependencies: List<IrContextualTypeKey> =
      listOf(IrContextualTypeKey.create(aliasedType))
    override val nameHint: String = ir?.name?.asString() ?: typeKey.type.rawType().name.asString()
    override val contextualTypeKey: IrContextualTypeKey = IrContextualTypeKey(typeKey)

    private fun resolveSourceDeclaration(
      ir: IrSimpleFunction?
    ): Pair<IrDeclarationWithName, Boolean>? {
      if (ir == null) return null
      return (ir.overriddenSymbolsSequence().lastOrNull()?.owner ?: ir).let {
        val isMetroContribution =
          it.parentClassOrNull?.hasAnnotation(Symbols.ClassIds.metroContribution) == true
        if (isMetroContribution) {
          // If it's a contribution, the source is
          // SourceClass.$$MetroContributionScopeName.bindingFunction
          //                                          ^^^
          it.parentAsClass.parentAsClass to true
        } else {
          it to false
        }
      }
    }

    override val reportableDeclaration: IrDeclarationWithName?
      get() {
        return resolveSourceDeclaration(ir)?.first
      }

    override fun renderLocationDiagnostic(short: Boolean): LocationDiagnostic {
      if ((annotations.isIntoMultibinding || annotations.isBinds) && ir != null) {
        val declarationData = resolveSourceDeclaration(ir)
        if (declarationData != null) {
          val (contributionSourceDeclaration, isContributed) = declarationData

          val location =
            contributionSourceDeclaration.locationOrNull()?.render(short)
              ?: "<unknown location, likely a separate compilation>"
          val description = buildString {
            if (isContributed) {
              append(contributionSourceDeclaration.expectAs<IrDeclarationParent>().kotlinFqName)
              append(" contributes a binding of ")
              appendLineWithUnderlinedContent(
                typeKey.render(short = short, includeQualifier = true)
              )
            } else {
              append(renderDescriptionDiagnostic(short = short, underlineTypeKey = true))
            }
          }
          return LocationDiagnostic(location, description)
        }
      }
      return super.renderLocationDiagnostic(short)
    }

    override fun renderDescriptionDiagnostic(short: Boolean, underlineTypeKey: Boolean) =
      buildString {
        if (ir == null) {
          append("Synthetic alias of ")
          append(aliasedType.render(short = short, includeQualifier = true))
          append(" to ")
          append(typeKey.render(short = short, includeQualifier = true))
          return@buildString
        }
        renderForDiagnostic(
          declaration = ir,
          short = short,
          typeKey = typeKey,
          annotations = annotations,
          parameters = parameters,
          isProperty = null,
          underlineTypeKey = underlineTypeKey,
        )
      }

    override fun toString() = renderDescriptionDiagnostic(short = true, underlineTypeKey = false)
  }

  @Poko
  class Assisted(
    @Poko.Skip override val type: IrClass,
    val target: IrContextualTypeKey,
    @Poko.Skip val function: IrSimpleFunction,
    override val annotations: MetroAnnotations<IrAnnotation>,
    override val parameters: Parameters,
    override val typeKey: IrTypeKey,
  ) : IrBinding, BindingWithAnnotations, InjectedClassBinding<Assisted> {
    // Dependencies are handled by the target class
    override val dependencies: List<IrContextualTypeKey> = listOf(target)
    override val nameHint: String = type.name.asString()
    override val scope: IrAnnotation? = null
    override val contextualTypeKey: IrContextualTypeKey = IrContextualTypeKey(typeKey)
    override val reportableDeclaration: IrDeclarationWithName
      get() = type

    override val isImplicitlyDeferrable: Boolean = true

    override fun withMapKey(mapKey: IrAnnotation?): Assisted {
      if (mapKey == null) return this
      return Assisted(
        type,
        target,
        function,
        annotations.copy(mapKeys = annotations.mapKeys + mapKey),
        parameters,
        typeKey,
      )
    }

    override fun renderDescriptionDiagnostic(short: Boolean, underlineTypeKey: Boolean) =
      buildString {
        append('(')
        append("@AssistedFactory")
        append(' ')
        type.parentClassOrNull?.let {
          append(it.name.asString())
          append('.')
        }
        append(typeKey.render(short = short, includeQualifier = false))
        append(')')
        append(' ')
        renderForDiagnostic(
          declaration = function,
          short = short,
          typeKey = typeKey,
          annotations = annotations,
          parameters = parameters,
          isProperty = null,
          underlineTypeKey = underlineTypeKey,
        )
      }

    override fun toString() = renderDescriptionDiagnostic(short = true, underlineTypeKey = false)
  }

  data class BoundInstance(
    override val typeKey: IrTypeKey,
    override val nameHint: String,
    override val reportableDeclaration: IrDeclarationWithName?,
    val classReceiverParameter: IrValueParameter? = null,
    val providerPropertyAccess: ParentContext.PropertyAccess? = null,
  ) : IrBinding {
    constructor(
      parameter: Parameter,
      reportableLocation: IrDeclarationWithName,
    ) : this(parameter.typeKey, "${parameter.name.asString()}Instance", reportableLocation)

    override val dependencies: List<IrContextualTypeKey> = emptyList()
    override val scope: IrAnnotation? = null
    override val parameters: Parameters = Parameters.empty()
    override val contextualTypeKey: IrContextualTypeKey = IrContextualTypeKey(typeKey)
    override val isImplicitlyDeferrable: Boolean = true

    override fun renderDescriptionDiagnostic(short: Boolean, underlineTypeKey: Boolean): String {
      return "BoundInstance(${typeKey.render(short = short, includeQualifier = true)})"
    }

    override fun toString() = renderDescriptionDiagnostic(short = true, underlineTypeKey = false)
  }

  data class Absent(override val typeKey: IrTypeKey) : IrBinding {
    override val dependencies: List<IrContextualTypeKey> = emptyList()
    override val scope: IrAnnotation? = null
    override val nameHint: String
      get() = reportCompilerBug("Should never be called")

    override val parameters: Parameters = Parameters.empty()
    override val contextualTypeKey: IrContextualTypeKey = IrContextualTypeKey(typeKey)
    override val isImplicitlyDeferrable: Boolean = true

    override val reportableDeclaration: IrDeclarationWithName? = null
    override val isTransient: Boolean = true

    override fun renderDescriptionDiagnostic(short: Boolean, underlineTypeKey: Boolean): String {
      return "Absent(${typeKey.render(short = short, includeQualifier = true)})"
    }

    override fun toString() = renderDescriptionDiagnostic(short = true, underlineTypeKey = false)
  }

  @Poko
  class GraphDependency(
    val ownerKey: IrTypeKey,
    @Poko.Skip val graph: IrClass,
    @Poko.Skip val getter: IrSimpleFunction? = null,
    override val typeKey: IrTypeKey,
    @Poko.Skip val propertyAccess: ParentContext.PropertyAccess? = null,
    val callableId: CallableId =
      propertyAccess?.property?.callableId
        ?: getter?.callableId
        ?: reportCompilerBug("One of getter or fieldAccess must be present"),
  ) : IrBinding {
    override val dependencies: List<IrContextualTypeKey> = listOf(IrContextualTypeKey(ownerKey))
    override val scope: IrAnnotation? = null
    override val nameHint: String = buildString {
      append(graph.name)
      if (propertyAccess != null) {
        append(propertyAccess.property.name)
      } else {
        val property = getter!!.correspondingPropertySymbol
        if (property != null) {
          val propName = property.owner.name.asString()
          if (!isWordPrefixRegex.matches(propName)) {
            append("Get")
          }
          append(propName.capitalizeUS())
        } else {
          append(getter.name.capitalizeUS())
        }
      }
    }
    override val parameters: Parameters = Parameters.empty()
    override val contextualTypeKey: IrContextualTypeKey = IrContextualTypeKey(typeKey)

    override val reportableDeclaration: IrDeclarationWithName?
      get() =
        propertyAccess?.property ?: getter?.propertyIfAccessor?.expectAs<IrDeclarationWithName>()

    override fun renderDescriptionDiagnostic(short: Boolean, underlineTypeKey: Boolean): String {
      // TODO render parent?
      return buildString {
        renderForDiagnostic(
          declaration = propertyAccess?.property?.reportableDeclaration ?: getter!!,
          short = short,
          typeKey = typeKey,
          annotations = MetroAnnotations.none(),
          parameters = Parameters.empty(),
          isProperty = null,
          underlineTypeKey = false,
        )
      }
    }

    override fun toString() = renderDescriptionDiagnostic(short = true, underlineTypeKey = false)
  }

  // TODO sets
  //  unscoped always initializes inline? Dagger sometimes generates private getters
  @Poko
  class Multibinding(
    override val typeKey: IrTypeKey,
    /** The original `@Multibinds` declaration, if any. Note this may point at a fake override. */
    @Poko.Skip var declaration: IrSimpleFunction?,
    val multibindsAnnotation: IrAnnotation?,
    val isSet: Boolean,
    val isMap: Boolean,
    /** Corresponds to @MultibindsElement.bindingId */
    val bindingId: String,
    var allowEmpty: Boolean,
    // Reconcile this with parametersByKey?
    // TreeSet sorting for consistency
    val sourceBindings: MutableSet<IrTypeKey> = TreeSet(),
  ) : IrBinding {
    override val scope: IrAnnotation? = null
    override val dependencies by memoize { sourceBindings.map { IrContextualTypeKey(it) } }
    override val parameters: Parameters = Parameters.empty()

    override val nameHint: String by memoize {
      buildString {
        if (isMap) {
          append("mapOf")
          val (k, v) = typeKey.type.requireSimpleType(declaration).arguments
          append(k.render(short = true).capitalizeUS())
          append("To")
          append(v.render(short = true).capitalizeUS())
        } else {
          append("setOf")
          append(
            typeKey.type
              .requireSimpleType(declaration)
              .arguments[0]
              .render(short = true)
              .capitalizeUS()
          )
        }
      }
    }

    override val contextualTypeKey: IrContextualTypeKey = IrContextualTypeKey(typeKey)

    override val reportableDeclaration: IrDeclarationWithName? = declaration

    override fun renderDescriptionDiagnostic(short: Boolean, underlineTypeKey: Boolean) =
      buildString {
        val decl = declaration
        if (decl != null) {
          renderForDiagnostic(
            declaration = decl,
            short = short,
            typeKey = typeKey,
            annotations = MetroAnnotations(multibinds = multibindsAnnotation),
            parameters = Parameters.empty(),
            isProperty = declaration?.isPropertyAccessor == true,
            underlineTypeKey = underlineTypeKey,
          )
        } else {
          typeKey.qualifier?.let {
            append(it.render(short = short))
            append(' ')
          }
          if (isSet) {
            append("Set<")
          } else {
            append("Map<")
          }
          append(typeKey.render(short = short, includeQualifier = false))
          append('>')
        }
      }

    fun addSourceBinding(source: IrTypeKey) {
      if (source in sourceBindings) {
        reportCompilerBug("Duplicate multibinding source: $source")
      }
      sourceBindings.add(source)
    }

    companion object {
      /**
       * Special case! Multibindings may be created under two conditions:
       * 1. Explicitly via `@Multibinds`
       * 2. Implicitly via a `@Provides` callable that contributes into a multibinding
       *
       * Because these may both happen, if the key already exists in the graph we won't try to add
       * it again
       */
      context(context: IrMetroContext)
      fun fromMultibindsDeclaration(
        getter: IrSimpleFunction,
        multibinds: IrAnnotation,
        contextualTypeKey: IrContextualTypeKey,
      ): Multibinding {
        return create(
          typeKey = contextualTypeKey.typeKey,
          declaration = getter,
          allowEmpty = multibinds.allowEmpty(),
          multibinds = multibinds,
        )
      }

      context(context: IrMetroContext)
      fun fromContributor(multibindingTypeKey: IrTypeKey): Multibinding {
        return create(
          typeKey = multibindingTypeKey,
          declaration = null,
          multibinds = null,
          allowEmpty = false,
        )
      }

      context(context: IrMetroContext)
      private fun create(
        typeKey: IrTypeKey,
        declaration: IrSimpleFunction?,
        multibinds: IrAnnotation?,
        allowEmpty: Boolean = false,
      ): Multibinding {
        val rawType = typeKey.type.rawType()

        val isSet = rawType.implements(context.irBuiltIns.setClass.owner.classId!!)
        val isMap = !isSet

        val bindingId: String =
          if (isMap) {
            val keyType = typeKey.type.requireSimpleType(declaration).arguments[0].typeOrFail
            createMapBindingId(keyType, typeKey)
          } else {
            typeKey.multibindingId
          }

        return Multibinding(
          typeKey,
          isSet = isSet,
          isMap = isMap,
          bindingId = bindingId,
          allowEmpty = allowEmpty,
          declaration = declaration,
          multibindsAnnotation = multibinds,
        )
      }
    }
  }

  data class MembersInjected(
    // Always MembersInjected<TargetClass>
    override val contextualTypeKey: IrContextualTypeKey,
    override val parameters: Parameters,
    override val reportableDeclaration: IrDeclarationWithName?,
    // Only present for inject() functions
    val function: IrFunction?,
    val isFromInjectorFunction: Boolean,
    val targetClassId: ClassId,
  ) : IrBinding {
    override val typeKey: IrTypeKey = contextualTypeKey.typeKey

    // MembersInjectors are always implicitly deferrable because they don't participate in
    // object instantiation
    override val isImplicitlyDeferrable: Boolean = true

    override val dependencies: List<IrContextualTypeKey> by memoize {
      parameters.nonDispatchParameters
        // Instance parameters are implicitly assisted in this scenario and marked as such in FIR
        .filterNot { it.isAssisted }
        .map { it.contextualTypeKey }
    }

    override val scope: IrAnnotation? = null

    override val nameHint: String by memoize { "${targetClassId.shortClassName}MembersInjector" }

    override fun renderDescriptionDiagnostic(short: Boolean, underlineTypeKey: Boolean) =
      buildString {
        typeKey.qualifier?.let {
          append(it.render(short = short))
          append(' ')
        }
        append("MembersInjector<")
        append(targetClassId.shortClassName.asString())
        append('>')
        if (function != null) {
          appendLine()
          appendLine("(injected at)")
          append("  ")
          renderForDiagnostic(
            declaration = function,
            short = short,
            typeKey = typeKey,
            annotations = MetroAnnotations.none(),
            parameters = parameters,
            isProperty = function.isPropertyAccessor,
            underlineTypeKey = underlineTypeKey,
            format = Format.CALL,
          )
        }
      }

    override fun toString() = renderDescriptionDiagnostic(short = true, underlineTypeKey = false)
  }

  /**
   * Represents a graph extension binding. Graph extensions are treated as bindings to enable
   * standard code generation for scoped instances when the extension graph itself is scoped.
   */
  @Poko
  class GraphExtension(
    override val typeKey: IrTypeKey,
    @Poko.Skip val parent: IrClass,
    val accessor: IrSimpleFunction,
    val extensionScopes: Set<IrAnnotation>,
    override val dependencies: List<IrContextualTypeKey> = emptyList(),
  ) : IrBinding {
    override val reportableDeclaration: IrDeclarationWithName = accessor
    override val contextualTypeKey: IrContextualTypeKey = IrContextualTypeKey(typeKey)
    override val parameters: Parameters = Parameters.empty()
    override val isImplicitlyDeferrable: Boolean = true

    // The scope field always returns null for GraphExtension
    // Use shouldBeScoped to check if this binding needs to be scoped
    override val scope: IrAnnotation? = null

    override val nameHint: String = typeKey.type.rawType().name.asString()

    /**
     * Returns true if this graph extension should be scoped (cached) in the parent graph. A graph
     * extension is scoped if it has any extension scopes defined.
     */
    override fun isScoped(): Boolean = extensionScopes.isNotEmpty()

    override fun renderDescriptionDiagnostic(short: Boolean, underlineTypeKey: Boolean) =
      buildString {
        renderForDiagnostic(
          declaration = accessor,
          annotations = MetroAnnotations.none(),
          short = short,
          typeKey = typeKey,
          underlineTypeKey = underlineTypeKey,
          parameters = Parameters.empty(),
          isProperty = accessor.isPropertyAccessor,
        )
      }

    override fun toString() = renderDescriptionDiagnostic(short = true, underlineTypeKey = false)
  }

  /**
   * Represents a graph extension factory binding. These are factories that create graph extensions
   * and need to participate in the binding graph for proper dependency resolution.
   */
  @Poko
  class GraphExtensionFactory(
    override val typeKey: IrTypeKey,
    val extensionTypeKey: IrTypeKey,
    val parent: IrClass,
    parentKey: IrTypeKey,
    val accessor: IrSimpleFunction,
  ) : IrBinding {
    override val dependencies: List<IrContextualTypeKey> = listOf(IrContextualTypeKey(parentKey))
    override val reportableDeclaration: IrDeclarationWithName = accessor
    override val contextualTypeKey: IrContextualTypeKey = IrContextualTypeKey(typeKey)
    override val parameters: Parameters = Parameters.empty()
    override val scope: IrAnnotation? = null
    override val nameHint: String = "${typeKey.type.rawType().name.asString()}Factory"

    override fun renderDescriptionDiagnostic(short: Boolean, underlineTypeKey: Boolean) =
      buildString {
        renderForDiagnostic(
          declaration = accessor,
          annotations = MetroAnnotations.none(),
          short = short,
          typeKey = typeKey,
          underlineTypeKey = underlineTypeKey,
          parameters = Parameters.empty(),
          isProperty = accessor.isPropertyAccessor,
        )
      }

    override fun toString() = renderDescriptionDiagnostic(short = true, underlineTypeKey = false)
  }

  /**
   * A custom wrapping type, such as an [java.util.Optional].
   *
   * Some types may natively support absence. To indicate this, set [wrappedContextKey] to indicate
   * [hasDefault = true][IrContextualTypeKey.hasDefault].
   *
   * Wrapper types may not have scopes.
   */
  @Poko
  class CustomWrapper(
    override val typeKey: IrTypeKey,
    val wrappedType: IrType,
    val wrappedContextKey: IrContextualTypeKey,
    // TODO
    //  could have multiple, do we want to report?
    //  this is the mirror function in local decls
    @Poko.Skip val declaration: IrSimpleFunction,
    val allowsAbsent: Boolean,
    val wrapperKey: String,
  ) : IrBinding {
    override val dependencies: List<IrContextualTypeKey> = listOf(wrappedContextKey)
    override val reportableDeclaration: IrDeclarationWithName = declaration
    override val contextualTypeKey: IrContextualTypeKey = IrContextualTypeKey(typeKey)
    override val parameters: Parameters = Parameters.empty()
    override val scope: IrAnnotation? = null
    override val nameHint: String = "$wrapperKey${wrappedType.rawType().name.asString()}"

    override fun renderDescriptionDiagnostic(short: Boolean, underlineTypeKey: Boolean) =
      buildString {
        renderForDiagnostic(
          declaration = declaration,
          annotations = MetroAnnotations.none(),
          short = short,
          typeKey = typeKey,
          underlineTypeKey = underlineTypeKey,
          parameters = Parameters.empty(),
          isProperty = declaration.isPropertyAccessor,
        )
      }

    override fun toString() = renderDescriptionDiagnostic(short = true, underlineTypeKey = false)
  }
}

context(builder: StringBuilder)
private fun IrClass.renderForDiagnostic(
  short: Boolean,
  annotations: MetroAnnotations<IrAnnotation>,
  underlineTypeKey: Boolean,
) {
  with(builder) {
    renderAnnotations(annotations, short, isClass = false)
    append(kind.codeRepresentation)
    append(' ')
    if (underlineTypeKey) {
      appendLineWithUnderlinedContent(name.asString())
    } else {
      append(name.asString())
    }
  }
}

private enum class Format {
  DECLARATION,
  CALL;

  val isDeclaration: Boolean
    get() = this == DECLARATION

  val isCall: Boolean
    get() = this == CALL
}

private fun StringBuilder.renderForDiagnostic(
  declaration: IrDeclarationParent,
  short: Boolean,
  typeKey: IrTypeKey,
  annotations: MetroAnnotations<IrAnnotation>?,
  parameters: Parameters,
  isProperty: Boolean?,
  underlineTypeKey: Boolean,
  format: Format = Format.DECLARATION,
) {
  val property: IrProperty?
  val name: Name
  val type: IrType
  when (declaration) {
    is IrField -> {
      property = null
      name = declaration.name
      type = declaration.type
    }
    is IrFunction -> {
      property = declaration.propertyIfAccessor.expectAsOrNull<IrProperty>()
      name = (property ?: declaration).name
      type = declaration.returnType
    }
    is IrProperty -> {
      property = declaration
      name = declaration.name
      type =
        declaration.getter?.returnType
          ?: declaration.backingField?.type
          ?: reportCompilerBug("No getter or backing field")
    }
    else -> {
      reportCompilerBug("Unsupported declaration type: ${declaration.dumpKotlinLike()}")
    }
  }

  val isProperty = isProperty == true || property != null

  if (format.isDeclaration) {
    annotations?.let { renderAnnotations(it, short, isClass = false) }
    if (isProperty) {
      if (property != null) {
        if (property.isVar) {
          if (property.isLateinit) {
            append("lateinit ")
          }
          append("var ")
        } else {
          append("val ")
        }
      } else {
        append("val ")
      }
    } else {
      append("fun ")
    }

    if (parameters.contextParameters.isNotEmpty()) {
      parameters.contextParameters.joinTo(this, ", ", prefix = "context(", postfix = ")\n") {
        it.name.asString() + ": " + it.typeKey.render(short = short)
      }
    }
  }

  val dispatchReceiverName =
    declaration.parentClassOrNull?.sourceGraphIfMetroGraph?.name?.asString()
  var hasReceiver = false

  if (format.isCall) {
    dispatchReceiverName?.let {
      append(it)
      hasReceiver = true
    }
  }

  parameters.extensionReceiverParameter?.let {
    if (format.isCall) {
      // Put the receiver in parens for context
      append('(')
    }
    it.typeKey.qualifier?.let { qualifier ->
      append(qualifier.render(short = short, "receiver"))
      append(' ')
    }
    append(it.typeKey.render(short = short))
    if (format.isCall) {
      // Put the receiver in parens for context
      append(')')
    }
    hasReceiver = true
  }

  if (hasReceiver) {
    append('.')
  }

  append(name.asString())

  val paramsToDisplay =
    if (format.isCall) {
      // Likely member inject() call
      parameters.regularParameters.filterNot { it.isAssisted }
    } else {
      parameters.regularParameters
    }
  if (paramsToDisplay.isNotEmpty()) {
    paramsToDisplay.joinTo(this, ", ", prefix = "(", postfix = ")\n") {
      it.name.asString() + ": " + it.typeKey.render(short = short, includeQualifier = true)
    }
  } else if (!isProperty) {
    append("()")
  }

  if (!(declaration is IrFunction && type.isUnit())) {
    append(": ")
    val returnTypeString = typeKey.render(short = short, includeQualifier = false)
    if (underlineTypeKey) {
      appendLineWithUnderlinedContent(returnTypeString)
    } else {
      append(returnTypeString)
    }
  }
}

private fun StringBuilder.renderAnnotations(
  annotations: MetroAnnotations<IrAnnotation>,
  short: Boolean,
  isClass: Boolean,
) {
  val annotationStrings =
    with(annotations) {
      buildList {
        qualifier?.let { add(it.render(short = short)) }
        if (isBinds) add("@Binds")
        if (isProvides) add("@Provides")
        if (isIntoSet) add("@IntoSet")
        if (isElementsIntoSet) add("@ElementsIntoSet")
        if (isMultibinds) add("@Multibinds")
        if (isBindsOptionalOf) add("@BindsOptionalOf")
        scope?.let { add(it.render(short = short)) }
        if (isIntoMap) add("@IntoMap")
        mapKeys.forEach { add(it.render(short = short)) }
        if (isClass) {
          if (isInject) add("@Inject")
        }
      }
    }
  when (annotationStrings.size) {
    0 -> {
      // do nothing
    }
    1,
    2 -> {
      annotationStrings.joinTo(this, " ")
      append(' ')
    }
    else -> {
      annotationStrings.joinTo(this, "\n")
      appendLine()
    }
  }
}

internal val IrBinding.isIntoMultibinding: Boolean
  get() {
    return typeKey.qualifier?.ir?.annotationClass?.classId == Symbols.ClassIds.MultibindingElement
  }

internal val IrBinding.hostParent: IrDeclarationContainer?
  get() {
    return when (val decl = reportableDeclaration) {
      is IrClass -> decl
      is IrPackageFragment -> decl
      is IrFunction,
      is IrProperty ->
        decl.parentDeclarationsWithSelf.firstNotNullOfOrNull {
          it as? IrClass ?: it as? IrPackageFragment
        }
      else -> null
    }
  }
